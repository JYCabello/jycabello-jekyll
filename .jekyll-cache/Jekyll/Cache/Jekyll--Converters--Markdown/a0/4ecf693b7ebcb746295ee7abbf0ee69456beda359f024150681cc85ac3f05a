I"Š?<p>So, youâ€™re using an Object Relational Mapper of any kind and you have to, letâ€™s say, remove a field from one of your models. This is a breaking change, as your contract with the database is going to break. If you have a small project that you can just take down for every release, thatâ€™s not a big deal, but:</p>

<p>Add an insult by having a CD pipeline that will do a gradual rollout, having two versions of your solution running: One with the field, and one without it.</p>

<p>Insult, meet injury: The migrations are run as part of the pipeline and not the project startup (I will write an article on how to do this bit with EF Core + Azure Pipelines, cause it got some nasty caveats to sort). This step should not have any impact on the complexity of the migration, but it does, as there is the possibility that the migration will run, but the deployment will crash, leaving you out cold in the water.</p>

<ul>
  <li>This adds a layer of security, by having your app get only limited read/write access to the database instead of the capacity to <a href="https://xkcd.com/327/">drop tables</a>.</li>
  <li>Makes the startup faster, as you know that the database is always in the latest version.</li>
</ul>

<p>I will present the process with an example in Entity Framework Core, but the idea behind it applies to any technology you use. Even if you donâ€™t have a proper ORM, if your database migrations are part of your pipeline, this article is for you.</p>

<p><em>Iâ€™m taking for granted that you know how to have a migrations-enabled project and that you know how to generate a new migration</em>.</p>

<p>Weâ€™ll start with this model:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">FruitBasket</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Banana</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">ID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Pear</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Zucchini</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This model is already part of a migration, it represents a fruit basked with a description of three fruits. The problem comes when you realise a Zucchini is not a fruit, so your first impulse would be to remove the Zucchini field:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">FruitBasket</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Banana</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">ID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Pear</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we do, make a migration and the exiting version tries to read a record from the database, we will see this in the logs:</p>

<pre><code class="language-log">Microsoft.Data.SqlClient.SqlException
Invalid column name 'Zucchini'.
</code></pre>

<p>Also, if we remove the field but not generate a migration, we will face this:</p>

<pre><code class="language-log">Microsoft.Data.SqlClient.SqlException
Cannot insert the value NULL into column 'Zucchini', table 'Fruits.dbo.FruitBaskets'; column does not allow nulls. INSERT fails.
</code></pre>

<p>So, how do we avoid this? This looks like a chicken-and-egg dilemma, except it does have an answer: Something comes first.</p>

<p>The idea is to make a series of deployments that keep the existing version working while moving us one step forward to the goal.</p>

<ol>
  <li>Make the field nullable, handle possible null values and generate no migration. Deploy that version. You are not changing the database, so the previous version will work with no problem, as the assumption that <code class="language-plaintext highlighter-rouge">Zucchini</code> cannot be <code class="language-plaintext highlighter-rouge">null</code> remains true. The new version will also work, as the only change is that the system is defensive against a problem that cannot happen.
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">public</span> <span class="k">class</span> <span class="nc">FruitBasket</span>
 <span class="p">{</span>
     <span class="k">public</span> <span class="kt">string</span> <span class="n">Banana</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
     <span class="k">public</span> <span class="kt">int</span> <span class="n">ID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
     <span class="k">public</span> <span class="kt">string</span> <span class="n">Pear</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
     <span class="k">public</span> <span class="kt">string</span><span class="p">?</span> <span class="n">Zucchini</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Generate a migration and deploy. That makes the column nullable. Code is the same, so both exiting and entering version will work with this database version.
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">NullableZucchini</span> <span class="p">:</span> <span class="n">Migration</span>
 <span class="p">{</span>
     <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Down</span><span class="p">(</span><span class="n">MigrationBuilder</span> <span class="n">migrationBuilder</span><span class="p">)</span> <span class="p">=&gt;</span>
         <span class="n">migrationBuilder</span><span class="p">.</span><span class="n">AlterColumn</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span>
             <span class="s">"Zucchini"</span><span class="p">,</span>
             <span class="s">"FruitBaskets"</span><span class="p">,</span>
             <span class="s">"nvarchar(max)"</span><span class="p">,</span>
             <span class="n">nullable</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
             <span class="n">defaultValue</span><span class="p">:</span> <span class="s">""</span><span class="p">,</span>
             <span class="n">oldClrType</span><span class="p">:</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">),</span>
             <span class="n">oldType</span><span class="p">:</span> <span class="s">"nvarchar(max)"</span><span class="p">,</span>
             <span class="n">oldNullable</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span>

     <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Up</span><span class="p">(</span><span class="n">MigrationBuilder</span> <span class="n">migrationBuilder</span><span class="p">)</span> <span class="p">=&gt;</span>
         <span class="n">migrationBuilder</span><span class="p">.</span><span class="n">AlterColumn</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span>
             <span class="s">"Zucchini"</span><span class="p">,</span>
             <span class="s">"FruitBaskets"</span><span class="p">,</span>
             <span class="s">"nvarchar(max)"</span><span class="p">,</span>
             <span class="n">nullable</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
             <span class="n">oldClrType</span><span class="p">:</span> <span class="k">typeof</span><span class="p">(</span><span class="kt">string</span><span class="p">),</span>
             <span class="n">oldType</span><span class="p">:</span> <span class="s">"nvarchar(max)"</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Remove the field altogether so you are not trying to access the column, no migration. Deploy. The exiting version will still work, as the column exists and is treated as nullable, entering one will ignore the column and inserts will work because the column is nullable.
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">public</span> <span class="k">class</span> <span class="nc">FruitBasket</span>
 <span class="p">{</span>
     <span class="k">public</span> <span class="kt">string</span> <span class="n">Banana</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
     <span class="k">public</span> <span class="kt">int</span> <span class="n">ID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
     <span class="k">public</span> <span class="kt">string</span> <span class="n">Pear</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Generate a migration to finally remove the column, deploy and you are done. The exiting version has no reference to the field, so it will work and since the new version has no changes in the code, the entering one will do, too.
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">RemoveZucchini</span> <span class="p">:</span> <span class="n">Migration</span>
 <span class="p">{</span>
     <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Down</span><span class="p">(</span><span class="n">MigrationBuilder</span> <span class="n">migrationBuilder</span><span class="p">)</span> <span class="p">=&gt;</span>
         <span class="n">migrationBuilder</span><span class="p">.</span><span class="n">AddColumn</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(</span>
             <span class="s">"Zucchini"</span><span class="p">,</span> 
             <span class="s">"FruitBaskets"</span><span class="p">,</span> 
             <span class="s">"nvarchar(max)"</span><span class="p">,</span> 
             <span class="n">nullable</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span>

     <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Up</span><span class="p">(</span><span class="n">MigrationBuilder</span> <span class="n">migrationBuilder</span><span class="p">)</span> <span class="p">=&gt;</span>
         <span class="n">migrationBuilder</span><span class="p">.</span><span class="nf">DropColumn</span><span class="p">(</span><span class="s">"Zucchini"</span><span class="p">,</span> <span class="s">"FruitBaskets"</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>Profit.</li>
</ol>

<p>Same process works on the inverse, if you wanted to introduce a non-nullable field, you would have to take similar steps. Except we would skip one step and we might need to do some data sanitizing in the end.</p>

<ol>
  <li>Introduce the field as nullable and generate the migration to introduce the field. Make sure that you donâ€™t leave the field out in any insertion.</li>
  <li>Make the field not nullable, generate a migration with a default value, perhaps a placeholder value if you have to sanitize/seed data later. Try to avoid doing both things in the same step if you can.</li>
  <li>Do any possible seeding and/or sanitizing, like changing the default values based on the category of the record.</li>
</ol>

<p>The difficulty with this is that, as developers, backwards compatibility comes naturally to us, as it appears on the wild often, but itâ€™s a challenge to think on forward compatibility. Good thing is that we live in an era where most projects that face this kind of challenge have some degree of automated check coverage, so an often effective heuristic is to run your migration locally, checkout the version that doesnâ€™t have it and run your suite. Try to be wise about it and do some exploratory testing in the areas of your system that have something to do with the changes at hand.</p>

<p>You can find the sample project <a href="https://github.com/JYCabello/ef-examples">here</a>, I might add some extra migrations on top of it to show relations in another article, mind you. Git history is your ally here.</p>

<p><span>Photo by <a href="https://unsplash.com/@jnaberle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Jan-Niclas Aberle</a> on <a href="https://unsplash.com/s/photos/migration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span></p>
:ET